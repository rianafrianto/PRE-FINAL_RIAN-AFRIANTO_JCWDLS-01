{"ast":null,"code":"export const createImage = url => new Promise((resolve, reject) => {\n  const image = new Image();\n  image.addEventListener(\"load\", () => resolve(image));\n  image.addEventListener(\"error\", error => reject(error));\n  image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\n\n  image.src = url;\n});\nexport function getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\n\nexport function rotateSize(width, height, rotation) {\n  const rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}\n/**\r\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\r\n */\n\nexport default async function getCroppedImg(imageSrc, pixelCrop) {\n  let rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let flip = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    horizontal: false,\n    vertical: false\n  };\n  const image = await createImage(imageSrc);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n\n  if (!ctx) {\n    return null;\n  }\n\n  const rotRad = getRadianAngle(rotation); // calculate bounding box of the rotated image\n\n  const {\n    width: bBoxWidth,\n    height: bBoxHeight\n  } = rotateSize(image.width, image.height, rotation); // set canvas size to match the bounding box\n\n  canvas.width = bBoxWidth;\n  canvas.height = bBoxHeight; // translate canvas context to a central location to allow rotating and flipping around the center\n\n  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);\n  ctx.rotate(rotRad);\n  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\n  ctx.translate(-image.width / 2, -image.height / 2); // draw rotated image\n\n  ctx.drawImage(image, 0, 0); // croppedAreaPixels values are bounding box relative\n  // extract the cropped image using these values\n\n  const data = ctx.getImageData(pixelCrop.x, pixelCrop.y, pixelCrop.width, pixelCrop.height); // set canvas width to final desired crop size - this will clear existing context\n\n  canvas.width = pixelCrop.width;\n  canvas.height = pixelCrop.height; // paste generated rotate image at the top left corner\n\n  ctx.putImageData(data, 0, 0); // As Base64 string\n  // return canvas.toDataURL('image/jpeg');\n  // As a blob\n\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(file => {\n      resolve(URL.createObjectURL(file));\n    }, \"image/jpeg\");\n  });\n}","map":{"version":3,"sources":["C:/Users/Riana/OneDrive/Desktop/Mini Project/fullstack/frontend/src/helpers/getCroppedImg.js"],"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","getRadianAngle","degreeValue","Math","PI","rotateSize","width","height","rotation","rotRad","abs","cos","sin","getCroppedImg","imageSrc","pixelCrop","flip","horizontal","vertical","canvas","document","createElement","ctx","getContext","bBoxWidth","bBoxHeight","translate","rotate","scale","drawImage","data","getImageData","x","y","putImageData","toBlob","file","URL","createObjectURL"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAIC,GAAD,IACzB,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/B,QAAMC,KAAK,GAAG,IAAIC,KAAJ,EAAd;AACAD,EAAAA,KAAK,CAACE,gBAAN,CAAuB,MAAvB,EAA+B,MAAMJ,OAAO,CAACE,KAAD,CAA5C;AACAA,EAAAA,KAAK,CAACE,gBAAN,CAAuB,OAAvB,EAAiCC,KAAD,IAAWJ,MAAM,CAACI,KAAD,CAAjD;AACAH,EAAAA,KAAK,CAACI,YAAN,CAAmB,aAAnB,EAAkC,WAAlC,EAJ+B,CAIiB;;AAChDJ,EAAAA,KAAK,CAACK,GAAN,GAAYT,GAAZ;AACD,CAND,CADK;AASP,OAAO,SAASU,cAAT,CAAwBC,WAAxB,EAAqC;AAC1C,SAAQA,WAAW,GAAGC,IAAI,CAACC,EAApB,GAA0B,GAAjC;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,MAA3B,EAAmCC,QAAnC,EAA6C;AAClD,QAAMC,MAAM,GAAGR,cAAc,CAACO,QAAD,CAA7B;AAEA,SAAO;AACLF,IAAAA,KAAK,EACHH,IAAI,CAACO,GAAL,CAASP,IAAI,CAACQ,GAAL,CAASF,MAAT,IAAmBH,KAA5B,IAAqCH,IAAI,CAACO,GAAL,CAASP,IAAI,CAACS,GAAL,CAASH,MAAT,IAAmBF,MAA5B,CAFlC;AAGLA,IAAAA,MAAM,EACJJ,IAAI,CAACO,GAAL,CAASP,IAAI,CAACS,GAAL,CAASH,MAAT,IAAmBH,KAA5B,IAAqCH,IAAI,CAACO,GAAL,CAASP,IAAI,CAACQ,GAAL,CAASF,MAAT,IAAmBF,MAA5B;AAJlC,GAAP;AAMD;AAED;AACA;AACA;;AACA,eAAe,eAAeM,aAAf,CACbC,QADa,EAEbC,SAFa,EAKb;AAAA,MAFAP,QAEA,uEAFW,CAEX;AAAA,MADAQ,IACA,uEADO;AAAEC,IAAAA,UAAU,EAAE,KAAd;AAAqBC,IAAAA,QAAQ,EAAE;AAA/B,GACP;AACA,QAAMvB,KAAK,GAAG,MAAML,WAAW,CAACwB,QAAD,CAA/B;AACA,QAAMK,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAf;AACA,QAAMC,GAAG,GAAGH,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAAZ;;AAEA,MAAI,CAACD,GAAL,EAAU;AACR,WAAO,IAAP;AACD;;AAED,QAAMb,MAAM,GAAGR,cAAc,CAACO,QAAD,CAA7B,CATA,CAWA;;AACA,QAAM;AAAEF,IAAAA,KAAK,EAAEkB,SAAT;AAAoBjB,IAAAA,MAAM,EAAEkB;AAA5B,MAA2CpB,UAAU,CACzDV,KAAK,CAACW,KADmD,EAEzDX,KAAK,CAACY,MAFmD,EAGzDC,QAHyD,CAA3D,CAZA,CAkBA;;AACAW,EAAAA,MAAM,CAACb,KAAP,GAAekB,SAAf;AACAL,EAAAA,MAAM,CAACZ,MAAP,GAAgBkB,UAAhB,CApBA,CAsBA;;AACAH,EAAAA,GAAG,CAACI,SAAJ,CAAcF,SAAS,GAAG,CAA1B,EAA6BC,UAAU,GAAG,CAA1C;AACAH,EAAAA,GAAG,CAACK,MAAJ,CAAWlB,MAAX;AACAa,EAAAA,GAAG,CAACM,KAAJ,CAAUZ,IAAI,CAACC,UAAL,GAAkB,CAAC,CAAnB,GAAuB,CAAjC,EAAoCD,IAAI,CAACE,QAAL,GAAgB,CAAC,CAAjB,GAAqB,CAAzD;AACAI,EAAAA,GAAG,CAACI,SAAJ,CAAc,CAAC/B,KAAK,CAACW,KAAP,GAAe,CAA7B,EAAgC,CAACX,KAAK,CAACY,MAAP,GAAgB,CAAhD,EA1BA,CA4BA;;AACAe,EAAAA,GAAG,CAACO,SAAJ,CAAclC,KAAd,EAAqB,CAArB,EAAwB,CAAxB,EA7BA,CA+BA;AACA;;AACA,QAAMmC,IAAI,GAAGR,GAAG,CAACS,YAAJ,CACXhB,SAAS,CAACiB,CADC,EAEXjB,SAAS,CAACkB,CAFC,EAGXlB,SAAS,CAACT,KAHC,EAIXS,SAAS,CAACR,MAJC,CAAb,CAjCA,CAwCA;;AACAY,EAAAA,MAAM,CAACb,KAAP,GAAeS,SAAS,CAACT,KAAzB;AACAa,EAAAA,MAAM,CAACZ,MAAP,GAAgBQ,SAAS,CAACR,MAA1B,CA1CA,CA4CA;;AACAe,EAAAA,GAAG,CAACY,YAAJ,CAAiBJ,IAAjB,EAAuB,CAAvB,EAA0B,CAA1B,EA7CA,CA+CA;AACA;AAEA;;AACA,SAAO,IAAItC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCyB,IAAAA,MAAM,CAACgB,MAAP,CAAeC,IAAD,IAAU;AACtB3C,MAAAA,OAAO,CAAC4C,GAAG,CAACC,eAAJ,CAAoBF,IAApB,CAAD,CAAP;AACD,KAFD,EAEG,YAFH;AAGD,GAJM,CAAP;AAKD","sourcesContent":["export const createImage = (url) =>\r\n  new Promise((resolve, reject) => {\r\n    const image = new Image();\r\n    image.addEventListener(\"load\", () => resolve(image));\r\n    image.addEventListener(\"error\", (error) => reject(error));\r\n    image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\r\n    image.src = url;\r\n  });\r\n\r\nexport function getRadianAngle(degreeValue) {\r\n  return (degreeValue * Math.PI) / 180;\r\n}\r\n\r\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\r\nexport function rotateSize(width, height, rotation) {\r\n  const rotRad = getRadianAngle(rotation);\r\n\r\n  return {\r\n    width:\r\n      Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\r\n    height:\r\n      Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\r\n  };\r\n}\r\n\r\n/**\r\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\r\n */\r\nexport default async function getCroppedImg(\r\n  imageSrc,\r\n  pixelCrop,\r\n  rotation = 0,\r\n  flip = { horizontal: false, vertical: false }\r\n) {\r\n  const image = await createImage(imageSrc);\r\n  const canvas = document.createElement(\"canvas\");\r\n  const ctx = canvas.getContext(\"2d\");\r\n\r\n  if (!ctx) {\r\n    return null;\r\n  }\r\n\r\n  const rotRad = getRadianAngle(rotation);\r\n\r\n  // calculate bounding box of the rotated image\r\n  const { width: bBoxWidth, height: bBoxHeight } = rotateSize(\r\n    image.width,\r\n    image.height,\r\n    rotation\r\n  );\r\n\r\n  // set canvas size to match the bounding box\r\n  canvas.width = bBoxWidth;\r\n  canvas.height = bBoxHeight;\r\n\r\n  // translate canvas context to a central location to allow rotating and flipping around the center\r\n  ctx.translate(bBoxWidth / 2, bBoxHeight / 2);\r\n  ctx.rotate(rotRad);\r\n  ctx.scale(flip.horizontal ? -1 : 1, flip.vertical ? -1 : 1);\r\n  ctx.translate(-image.width / 2, -image.height / 2);\r\n\r\n  // draw rotated image\r\n  ctx.drawImage(image, 0, 0);\r\n\r\n  // croppedAreaPixels values are bounding box relative\r\n  // extract the cropped image using these values\r\n  const data = ctx.getImageData(\r\n    pixelCrop.x,\r\n    pixelCrop.y,\r\n    pixelCrop.width,\r\n    pixelCrop.height\r\n  );\r\n\r\n  // set canvas width to final desired crop size - this will clear existing context\r\n  canvas.width = pixelCrop.width;\r\n  canvas.height = pixelCrop.height;\r\n\r\n  // paste generated rotate image at the top left corner\r\n  ctx.putImageData(data, 0, 0);\r\n\r\n  // As Base64 string\r\n  // return canvas.toDataURL('image/jpeg');\r\n\r\n  // As a blob\r\n  return new Promise((resolve, reject) => {\r\n    canvas.toBlob((file) => {\r\n      resolve(URL.createObjectURL(file));\r\n    }, \"image/jpeg\");\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}